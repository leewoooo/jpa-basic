영속성 컨텍스트
===

JPA에서 가장 중요한 2가지

1. 객체와 관계형 데이터베이스 **매핑**
2. **영속성 컨텍스트**

## 영속성 컨텍스트란?

**JPA를 이해하는데 가장 중요한 용어**이며 **엔티티를 영구 저장하는 환경 이라는 뜻**

```java
EntityManager.persist(entity); -> Database에 저장을 하는 것이 아닌 Entity를 영속성 컨텍스트에 저장을 한다는 뜻
```

영속성 컨텍스트는 **논리적**인 개념이며 `EntityManager`를 통해 영속성 컨텍스트에 접근을 하게 되는 것이다.

### 엔티티의 생명주기

1. 비영속
   - 영속성 컨텍스트오 전혀 관계가 없는 **새로운 상태** (Entity를 생성만 한 상태)
2. 영속
   - 영속성 컨텍스트에 **관리**되는 상태
   - EntityManager를 통해 Entity를 persist한 상태
   - DB에 저장하려면 `commit`를 해야한다. **`commit`가 되기 전까지는 영속 상태이더라도 DB에 저장되지 않음.**
   - 영속성 컨텍스트의 이점을 사용할 수 없음
3. 준영속
   - 영속성 컨텍스트에 있다가 **분리**된 상태
   - `em.detach()`를 이용하여 해당 Entity를 영속성 컨텍스트에서 분리
4. 삭제
   - 영속성 컨텍스트에 삭제 된 상태 (Database에 삭제 요청)
   - `em.remove()`를 이용하여 Database에서 삭제 요청

## 영속성 컨텍스트의 이점

영속성 컨텍스트는 **애플리케이션과 Database** 중간에 위치하면서 이점을 가져갈 수 있다.

### 1차 캐시

영속성 컨텍스트는 엔티티가 영속되면 해당 엔티티를 **key:@id, value:Entity** map 형식으로 **1차 캐시에 저장한다.**

이 후 @id 값을 이용하여 조회를 할 때 순서는 다음과 같다.

1. 1차 캐시에 key값으로 **@id에 해당하는 값이 있는지 찾고** 있으면 return (1차 캐시에 있다면 Database에 select query를 보내지 않기 떄문에 성능상 이점)
2. 만약 없다면 DB에서 조회하여 return 후 **찾은 Entity를 1차 캐시에 저장한다.**

### 영속 엔티티의 동일성 보장

간단하게 이야기하면 **같은 트랜잭션 안에서 동일한 key값으로 엔티티를 조회할 때** return해주는 엔티티의 참조값은 모두 동일하다.

1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 Database가 아닌 애플리케이션 등급에서 처리를 해준다.

### 엔티티 등록

`commit`이 되기 전까지 EntityManger를 통해 엔티티를 **영속성 컨텍스트에 영속시킨 후 한번에 commit하여 Database에 저장할 수 있다.**

내부 작업 순서는 다음과 같다.

1. EntityManager를 통해 엔티티를 `persist`하여 1차 캐시에 올린다.

2. JPA가 엔티티를 분석하여 **Insert query를 만들고 쓰기 지연 SQL저장소에 저장한다.**

3. **`commit`가 되는 시점**에서 쓰기 지연 SQL저장소에 있는 query를 실행한다. --> 즉 엔티티를 한번에 저장할 수 있다.


```java
em.persist(memberA); 
em.persist(memberB);

tx.commit(); // flush
```

### 엔티티 수정 (변경 감지)

영속성 컨텍스트에서 관리하고 있는 **엔티티의 상태가 수정되었을 때** JPA는 해당 엔티티의 상태가 변경되었음을 감지하고
`commit`이 되는 시점에 Entity를 변경하여 **Database에 적용시켜 준다.** (Update를 따로 명시해줘야 하지 않을까? 저장을 새로 해줘야 하지 않을까? 궁금증이 생김)

내부 작업 순서는 다음과 같다.

1. Database에서 엔티티를 조회한 시점(최초 시점)의 **스냅샷을** 만들어 영속성 컨텍스트에 저장해 놓는다.
2. Entity가 변경이 되었다면 **스냅샷과 현재 엔티티를 비교한다.**
3. 변경된 내역을 확인하여 **쓰기 지연 SQL저장소에 Update query를 저장한다.**
4. **트랜잭션이 `commit`되는 시점**에 쓰기 지연 SQL저장소에서 Update query를 Database로 보내게 된다.

`merge`를 이용하는 방법도 있지만 **변경감지(dirty checking)을 지향**한다.

## Flush

영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는 것을 이야기한다. 즉 `commit`되는 시점 `flush`가 일어난다.

### 플러시가 발생하면?

- 변경 감지
- 수정 된 엔티티 쓰기 지연 SQL 저장소에 등록
- **쓰기 지연 SQL 저장소의 쿼리를 Database에 전송.**

### 플러시 하는 방법

1. `em.flush()`
2. 트랜잭션 `commit` - 자동으로 `flush` 호출
3. JPQL query 실행 - 자동으로 `flush` 호출

### 플러시는

플러시가 일어난다고 **영속성 컨텍스트를 비우지 않는다.**

플러시는 **영속성 컨텍스트의 변경내용을 데이터 베이스와 동기화** 한다. (commit없이 플러시만 일어난다고 Database에 변경점이 적용되지 않음.)
